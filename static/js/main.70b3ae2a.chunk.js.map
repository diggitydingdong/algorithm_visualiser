{"version":3,"sources":["Grid.tsx","App.tsx","index.tsx"],"names":["COLOURS","Grid","width","height","random","useStateWithCallbackLazy","o","row","push","col","Math","floor","length","getGrid","cells","setCells","nextCells","useRef","currCount","isOob","coord","useEffect","setInterval","current","nextCoords","newCells","map","slice","forEach","currentCells","newNeighbours","grid","relativeNeighbour","n","getNeighbours","newNeighbour","array","element","isIn","findIndex","id","rowIdx","className","cellValue","colIdx","onMouseDown","e","handleClick","App","props","state","hasError","this","error","console","React","Component","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.70b3ae2a.chunk.js","sourcesContent":["import React, { useEffect, useRef } from \"react\";\r\nimport './Grid.css';\r\nimport { useStateWithCallbackLazy } from \"use-state-with-callback\";\r\n\r\nexport interface GridProps {\r\n    width: number;\r\n    height: number;\r\n    random?: boolean;\r\n}\r\n\r\nconst coordIsIn = (array: coordinate[], element: coordinate): number => {\r\n    return array.findIndex((coord) => coord[0] === element[0] && coord[1] === element[1]);\r\n}\r\n\r\nconst waitTime = 25;\r\n\r\nfunction getGrid(width: number, height: number, random: boolean): number[][] {\r\n    const o: number[][] = [];\r\n    for (let row = 0; row < height; row++) {\r\n      o.push([]);\r\n      for (let col = 0; col < width; col++) {\r\n        o[row].push(random ? Math.floor(Math.random()*COLOURS.length) : 0);\r\n      }\r\n    }\r\n    return o;\r\n}\r\n\r\nconst COLOURS = ['red', 'orange', 'yellow', 'green', 'blue'] as const;\r\n\r\ntype Colour = typeof COLOURS[number];\r\n\r\ntype coordinate = [row: number, col: number, colour: number];\r\n\r\nexport const Grid: React.FC<GridProps> = ({ width, height, random }) => {\r\n    const [ cells, setCells ] = useStateWithCallbackLazy<number[][]>(getGrid(width, height, !!random));\r\n    const nextCells = useRef<coordinate[]>([]);\r\n    const currCount = useRef(0);\r\n\r\n    const isOob = (coord: coordinate): boolean => (coord[0] < 0 || coord[1] < 0 || coord[0] >= height || coord[1] >= width);\r\n\r\n    const getNeighbours = (grid: number[][], coord: coordinate): coordinate[] => {\r\n        const o: coordinate[] = [];\r\n\r\n        const relativeCoordsOfNeighbours: coordinate[] = [ [1, 0, coord[2]], [0, 1, coord[2]], [-1, 0, coord[2]], [0, -1, coord[2]] ];\r\n\r\n        for(const relativeNeighbour of relativeCoordsOfNeighbours) {\r\n            const n: coordinate = [coord[0]+relativeNeighbour[0], coord[1]+relativeNeighbour[1], coord[2]];\r\n            \r\n            if(!isOob(n) && grid[n[0]][n[1]] < coord[2]) o.push(n);\r\n        }\r\n\r\n        return o;\r\n    }\r\n\r\n    const handleClick = (rowIdx: number, colIdx: number): void => {\r\n        currCount.current++; \r\n        if(cells[rowIdx][colIdx] === currCount.current % COLOURS.length) return;\r\n        nextCells.current.push([rowIdx, colIdx, currCount.current]); \r\n\r\n    }\r\n\r\n    useEffect(() => {setInterval(() => {\r\n        if(nextCells.current.length === 0) return;\r\n\r\n        const nextCoords: coordinate[] = [...nextCells.current];\r\n\r\n        nextCells.current = [];\r\n\r\n        setCells(cells => {\r\n            // Deep copy the 2D array\r\n            const newCells = cells.map(row => row.slice());\r\n\r\n            // Update newCells with our next coordinates\r\n            nextCoords.forEach(coord => {\r\n                newCells[coord[0]][coord[1]] = coord[2];\r\n            })\r\n\r\n            // Render\r\n            return newCells;\r\n        }, (currentCells: number[][]) => {for(const coord of nextCoords) {\r\n            const newNeighbours = getNeighbours(currentCells, coord);\r\n            const n: coordinate[] = [];\r\n            newNeighbours.forEach(newNeighbour => {\r\n                const isIn = coordIsIn(nextCells.current, newNeighbour)\r\n                if(isIn === -1) n.push(newNeighbour);\r\n                else if(nextCells.current[isIn][2] < newNeighbour[2]) {\r\n                    nextCells.current[isIn][2] = newNeighbour[2];\r\n                }\r\n            })\r\n            nextCells.current.push(...n);\r\n        }})\r\n        \r\n    }, waitTime);}, [])\r\n\r\n\r\n    if (!cells) return <div>Loading...</div>;\r\n    return (\r\n        <div id=\"grid\">\r\n            {cells.map((row, rowIdx) => (\r\n                <div className={\"row\"} key={rowIdx}>\r\n                    {row.map((cellValue, colIdx) => (\r\n                        <div className={\"cell \" + COLOURS[cellValue % COLOURS.length]} key={`${rowIdx} ${colIdx}`} onMouseDown={(e) => handleClick(rowIdx, colIdx)} />\r\n                    ))}\r\n                </div>\r\n            ))}\r\n        </div>\r\n  );\r\n}","import React from 'react';\nimport './App.css';\nimport { Grid } from './Grid';\n\nexport interface AppProps { }\n\nexport interface IAppState {\n  hasError: boolean;\n}\n\nexport class App extends React.Component<AppProps, IAppState> {\n  constructor(props: AppProps) {\n    super(props);\n\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error: Error) {\n    console.error(error);\n\n    // Update state so the next render will show the fallback UI.\n    return { hasError: true };\n  }\n\n  render() {\n    if(this.state.hasError) return <>ERROR!!!!!</>;\n\n    return (\n      <div className=\"App\">\n          <Grid width={59} height={29}/>\n      </div>\n    );\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport { App } from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}